// Â© Sanjaya
// Boleh diambil tapi izin dulu
// Terimakasih untuk Daffa, Shannz, dll 
// Module: @vioo/apis on NPM

const axios = require('axios')
const acrcloud = require('acrcloud')
const cheerio = require('cheerio')
const { createDecipheriv } = require('crypto')
const fs = require('fs')
const fetch = require('node-fetch')
const ffmpeg = require('fluent-ffmpeg')
const FormData = require('form-data')
const https = require('https')
const path = require('path')
const { spawn, exec, execSync } = require('child_process')
const WebSocket = require('ws')
const ytSearch = require('yt-search')

// === Main function

const randomKarakter = (length) => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  return Array.from({ length }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('')
}

const FileSize = (path) => {
  const bytes = fs.statSync(path).size
  if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB'
  if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB'
  if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB'
  return bytes + ' B'
}

// === Uploader

async function catbox(path) {
  const data = new FormData()
  data.append('reqtype', 'fileupload')
  data.append('userhash', '')
  data.append('fileToUpload', fs.createReadStream(path))
  const config = {
    method: 'POST',
    url: 'https://catbox.moe/user/api.php',
    headers: {
      ...data.getHeaders(),
      'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',
    },
    data: data
  }
  const api = await axios.request(config)
  return api.data
}

async function uguu(path) {
    try {
        const form = new FormData()
        form.append('files[]', fs.createReadStream(path))

        const { data } = await axios.post('https://uguu.se/upload', form, {
            headers: {
                ...form.getHeaders()
            }
        })

        return data.files[0].url
    } catch (err) {
        throw new Error(err.message)
    }
}

async function theoks(path) {
    try {
        let form = new FormData()
        form.append('files[]', fs.createReadStream(path))

        let { data } = await axios.post('https://pomf-api.theoks.net/upload.php', form, {
            headers: form.getHeaders()
        })

        return data.files[0].url
    } catch (err) {
        throw new Error(err.message)
    }
}

async function litterbox(path) {
    try {
        let form = new FormData()
        form.append('fileToUpload', fs.createReadStream(path))
        form.append('reqtype', 'fileupload')
        form.append('time', '24h')

        let { data } = await axios.post('https://litterbox.catbox.moe/resources/internals/api.php', form, {
            headers: {
                ...form.getHeaders()
            }
        })

        return data
    } catch (err) {
        throw new Error(err.message)
    }
}

async function cloudmini(path) {
    try {
        const file_buffer = fs.readFileSync(path)
        const file_type = path.split('.').pop()
        const file_name = path.split('/').pop()
        const unique_id = randomKarakter(2) + (file_buffer.length + file_type + file_name).length

        const form = new FormData()
        form.append('file', fs.createReadStream(path), `${unique_id}.${file_type}`)

        const response = await axios.post('https://files.cloudmini.net/upload', form, {
            headers: { ...form.getHeaders() }
        })

        const { filename } = response.data
        return `https://files.cloudmini.net/download/${filename}`
    } catch (err) {
        throw new Error(err.message)
    }
}

async function tempfiles(path) {
    try {
        const form = new FormData()
        form.append('file', fs.createReadStream(path))

        const { data } = await axios.post('https://tmpfiles.org/api/v1/upload', form, {
            headers: {
                ...form.getHeaders()
            }
        })

        return data.data.url
    } catch (err) {
        throw new Error(err.message)
    }
}

async function postimg(filePath) {
  try {
    let data = new FormData()
    data.append('optsize', '0')
    data.append('expire', '0')
    data.append('numfiles', '1')
    data.append('upload_session', Math.random())
    data.append('file', fs.createReadStream(filePath))

    const res = await axios.post('https://postimages.org/json/rr', data, {
      headers: { ...data.getHeaders() }
    })

    const html = await axios.get(res.data.url)
    const $ = cheerio.load(html.data)
    let image = $('#code_direct').attr('value')

    return image
  } catch (err) {
    throw Error(err.message)
  }
}

// === Downloader

async function ytdlv1(url, type) {
    const headers = {
        "accept": "*/*",
        "accept-language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
        "sec-ch-ua": '"Not A(Brand";v="8", "Chromium";v="132"',
        "sec-ch-ua-mobile": "?1",
        "sec-ch-ua-platform": '"Android"',
        "sec-fetch-dest": "empty",
        "sec-fetch-mode": "cors",
        "sec-fetch-site": "cross-site",
        "Referer": "https://id.ytmp3.mobi/",
        "Referrer-Policy": "strict-origin-when-cross-origin"
    }

    const randomKarakter = async (length) => {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
        let result = ''
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length))
        }
        return result
    }

    const initial = await axios.get(`https://d.ymcdn.org/api/v1/init?p=y&23=1llum1n471&_=${Math.random()}`, { headers })
    const init = initial.data

    const id = url.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^&?/]+)/)?.[1]

    let mp4_ = init.convertURL + `&v=${id}&f=mp4&_=${Math.random()}`
    let mp3_ = init.convertURL + `&v=${id}&f=mp3&_=${Math.random()}`

    const mp4__ = await axios.get(mp4_, { headers })
    const mp3__ = await axios.get(mp3_, { headers })

    let info = {}
    for (let i = 0; i < 3; i++) {
        let j = await axios.get(mp3__.data.progressURL, { headers })
        info = j.data
        if (info.progress == 3) break
    }

    let result_url = type === 'mp4' ? mp4__.data.downloadURL : mp3__.data.downloadURL
    const buffer = await axios({ url: result_url, headers, responseType: 'arraybuffer' })
    const file_path = `./lib/${await randomKarakter(5)}.${type}`
    fs.writeFileSync(file_path, buffer.data)

    return {
        title: info.title,
        file_path
    }
}

async function ytdlv2(url, type, quality) {
  const api = {
    base: 'https://media.savetube.me/api',
    cdn: '/random-cdn',
    info: '/v2/info',
    download: '/download'
  }

  const headers = {
    accept: '*/*',
    'content-type': 'application/json',
    origin: 'https://yt.savetube.me',
    referer: 'https://yt.savetube.me/',
    'user-agent': 'Postify/1.0.0'
  }

  const vid_quality = ['144', '240', '360', '480', '720', '1080']
  const aud_quality = ['32', '64', '128', '192', '256', '320']

  const hex_to_buf = (hex) => Buffer.from(hex, 'hex')

  const decrypt = (enc) => {
    try {
      const secret_key = 'C5D58EF67A7584E4A29F6C35BBC4EB12'
      const data = Buffer.from(enc, 'base64')
      const iv = data.slice(0, 16)
      const content = data.slice(16)
      const key = hex_to_buf(secret_key)

      const decipher = createDecipheriv('aes-128-cbc', key, iv)
      let decrypted = Buffer.concat([decipher.update(content), decipher.final()])

      return JSON.parse(decrypted.toString())
    } catch (error) {
      throw new Error(error.message)
    }
  }

  const get_id = (url) => {
    const regex = [
      /youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/v\/([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
      /youtu\.be\/([a-zA-Z0-9_-]{11})/
    ]
    for (let r of regex) {
      let match = url.match(r)
      if (match) return match[1]
    }
    return null
  }

  const dl_file = (url, file_path) => {
    return new Promise(async (resolve, reject) => {
      try {
        const response = await axios({
          url,
          method: 'GET',
          responseType: 'stream'
        })
        const writer = fs.createWriteStream(file_path)
        response.data.pipe(writer)
        writer.on('finish', () => resolve(file_path))
        writer.on('error', reject)
      } catch (error) {
        reject(error)
      }
    })
  }

  const convert_audio = (input, output, bitrate) => {
    return new Promise((resolve, reject) => {
      const process = spawn('ffmpeg', [
        '-i', 'pipe:0',
        '-b:a', `${bitrate}k`,
        '-preset', 'ultrafast',
        '-movflags', '+faststart',
        output
      ])
    
      const readStream = fs.createReadStream(input)
      readStream.pipe(process.stdin)

      process.on('close', (code) => {
        if (code === 0) resolve(output)
        else reject(new Error('Error :('))
      })
    })
  }

  const id = get_id(url)

  try {
    const { data: cdn_res } = await axios.get(api.base+api.cdn, { headers })
    const cdn = cdn_res.cdn

    const { data: info_res } = await axios.post(`https://${cdn}${api.info}`, {
      url: `https://www.youtube.com/watch?v=${id}`
    }, { headers })

    const decrypted = decrypt(info_res.data)

    if (type === 'mp4') {
      if (!vid_quality.includes(quality.toString())) quality = '360'
    } else if (type === 'mp3') {
      if (!aud_quality.includes(quality.toString())) quality = '192'
    }

    const { data: dl_res } = await axios.post(`https://${cdn}${api.download}`, {
      id,
      downloadType: type === 'mp3' ? 'audio' : 'video',
      quality,
      key: decrypted.key
    }, { headers })

    const file_name = `${randomKarakter(4)}.${type}`
    const file_path = './' + file_name

    await dl_file(dl_res.data.downloadUrl, file_path)

    if (type === 'mp3') {
      const output_file = `./${randomKarakter(4)}.mp3`
      await convert_audio(file_path, output_file, quality)
      fs.unlinkSync(file_path)
      return {
        title: decrypted.title,
        format: 'mp3',
        quality: quality+'kbps',
        duration: decrypted.duration,
        thumbnail: decrypted.thumbnail || `https://i.ytimg.com/vi/${id}/maxresdefault.jpg`,
        file_name: decrypted.title+'.mp3',
        file_size: FileSize(output_file),
        download: output_file
      }
    }

    return {
      title: decrypted.title,
      format: 'mp4',
      quality: quality+'p',
      duration: decrypted.duration,
      thumbnail: decrypted.thumbnail || `https://i.ytimg.com/vi/${id}/maxresdefault.jpg`,
      file_name: decrypted.title+'.mp4',
      file_size: FileSize(file_path),
      download: file_path
    }
  } catch (err) {
    return { error: err.message }
  }
}

async function getTokenFB() {
  const { data: html } = await axios.get("https://fbdown.me/")
  const $ = cheerio.load(html)
  return $("#token").val()
}

async function fbdl(url) {
  try {
    const token = await getTokenFB()
    const formData = new FormData()
    formData.append("url", url)
    formData.append("token", token)

    const { data } = await axios.post(
      "https://fbdown.me/wp-json/aio-dl/video-data",
      formData,
      { headers: { ...formData.getHeaders() } }
    )

    return {
      title: data.title,
      thumbnail: data.thumbnail,
      videos: data.medias.map(v => ({
        url: v.url,
        quality: v.quality,
        size: v.formattedSize
      }))
    }
  } catch (err) {
    throw Error(err.message)
  }
}

async function igdl(url) {
  const { data } = await axios.post(
    'https://yt1s.io/api/ajaxSearch',
    new URLSearchParams({
      p: 'home',
      q: url,
      w: '',
      lang: 'en'
    }),
    {
      headers: {
        'User-Agent': 'Postify/1.0.0',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'Accept': 'application/json, text/plain, */*',
        'Origin': 'https://yt1s.io',
        'Referer': 'https://yt1s.io/'
      }
    }
  )

  const $ = cheerio.load(data.data)

  return $('a.abutton.is-success.is-fullwidth.btn-premium')
    .map((_, el) => ({
      title: $(el).attr('title'),
      url: $(el).attr('href')
    }))
    .get()
}

async function ttdl(url) {
  return new Promise(async (resolve, reject) => {
    try {
      let data = []

      function formatNumber(integer) {
        let numb = parseInt(integer)
        return Number(numb).toLocaleString().replace(/,/g, '.')
      }

      function formatDate(n, locale = 'en') {
        let d = new Date(n)
        return d.toLocaleDateString(locale, {
          weekday: 'long',
          day: 'numeric',
          month: 'long',
          year: 'numeric',
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric'
        })
      }

      let domain = 'https://www.tikwm.com/api/'
      let res = await (await axios.post(domain, {}, {
        headers: {
          'Accept': 'application/json, text/javascript, */*; q=0.01',
          'Accept-Language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          'Origin': 'https://www.tikwm.com',
          'Referer': 'https://www.tikwm.com/',
          'Sec-Ch-Ua': '"Not)A;Brand" ;v="24" , "Chromium" ;v="116"',
          'Sec-Ch-Ua-Mobile': '?1',
          'Sec-Ch-Ua-Platform': 'Android',
          'Sec-Fetch-Dest': 'empty',
          'Sec-Fetch-Mode': 'cors',
          'Sec-Fetch-Site': 'same-origin',
          'User-Agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36',
          'X-Requested-With': 'XMLHttpRequest'
        },
        params: {
          url: url,
          count: 12,
          cursor: 0,
          web: 1,
          hd: 1
        }
      })).data.data
      if (!res.size) {
        res.images.map(v => {
          data.push({
            type: 'photo',
            url: v
          })
        })
      } else {
        data.push({
          type: 'watermark',
          url: 'https://www.tikwm.com' + res.wmplay,
        }, {
          type: 'nowatermark',
          url: 'https://www.tikwm.com' + res.play,
        }, {
          type: 'nowatermark_hd',
          url: 'https://www.tikwm.com' + res.hdplay
        })
      }
      let json = {
        title: res.title,
        region: res.region,
        durations: res.duration,
        cover: 'https://www.tikwm.com' + res.cover,
        size_wm: res.wm_size,
        size_nowm: res.size,
        size_nowm_hd: res.hd_size,
        data: data,
        music_info: {
          id: res.music_info.id,
          title: res.music_info.title,
          author: res.music_info.author,
          album: res.music_info.album ? res.music_info.album : null,
          url: 'https://www.tikwm.com' + res.music || res.music_info.play
        },
        stats: {
          views: formatNumber(res.play_count),
          likes: formatNumber(res.digg_count),
          comment: formatNumber(res.comment_count),
          share: formatNumber(res.share_count),
          download: formatNumber(res.download_count)
        },
        author: {
          id: res.author.id,
          fullname: res.author.unique_id,
          nickname: res.author.nickname,
          avatar: 'https://www.tikwm.com' + res.author.avatar
        }
      }
      resolve(json)
    } catch (e) {
      reject(e)
    }
  })
}

async function ttslide(url) {
  try {
    const res = await axios({
      method: 'POST',
      url: 'https://tikvideo.app/api/ajaxSearch',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36',
      },
      data: new URLSearchParams({ q: url, lang: 'id' }).toString(),
    })

    const result = []
    if (res.data.status === 'ok') {
      const $ = cheerio.load(res.data.data)
      $('img').each((index, element) => {
        const imgSrc = $(element).attr('src')
        if (imgSrc && !imgSrc.includes('.webp')) {
          result.push(imgSrc)
        }
      })
    }

    return result.length > 0 ? result : null
  } catch (err) {
    throw Error(err.message)
  }
}

async function spotify(url) {
  const hai = await axios.get(`https://api.fabdl.com/spotify/get?url=${encodeURIComponent(url)}`)
  const hao = await axios.get(`https://api.fabdl.com/spotify/mp3-convert-task/${hai.data.result.gid}/${hai.data.result.id}`)
  return {
    title: hai.data.result.name,
    download: `https://api.fabdl.com${hao.data.result.download_url}`,
    image: hai.data.result.image,
    duration: hai.data.result.duration_ms
  }
}

async function capcut(url) {
  const BASE_URI = "https://snapsave.cc/wp-json/aio-dl/video-data"
  const headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept': 'application/json, text/plain, */*',
    'Accept-Language': 'en-US,en;q=0.9',
    'Content-Type': 'application/json;charset=UTF-8',
    'Connection': 'keep-alive',
    'Referer': 'https://snapsave.cc/capcut-video-downloader/',
    'Origin': 'https://snapsave.cc',
    'X-Requested-With': 'XMLHttpRequest',
    'Cache-Control': 'no-cache',
    'Pragma': 'no-cache',
    'DNT': '1'
  }

  try {
    const response = await axios.get(`https://snapsave.cc/capcut-video-downloader/#url=${encodeURIComponent(url)}`, { headers })
    const $ = cheerio.load(response.data)
    const token = $("#token").val()

    const payload = {
      url,
      token,
      hash: "aHR0cHM6Ly93d3cuY2FwY3V0LmNvbS9pZC1pZC90ZW1wbGF0ZS1kZXRhaWwvRm9yLXlvdS0vNzQxNDE2Mjk3MzU3ODU2MjgyMg==1073YWlvLWRs"
    }

    const { data: videoData } = await axios.post(BASE_URI, payload, { headers })

    return {
      title: videoData.title,
      thumbnail: videoData.thumbnail,
      source: videoData.source,
      media: videoData.medias.map((item) => ({
        url: item.url,
        quality: item.quality,
        format: item.extension,
        size: item.formattedSize
      }))
    }

  } catch (err) {
    throw Error(err.message)
  }
}

async function threads(url) {
  try {
    const { data } = await axios.get('https://threads.snapsave.app/api/action', {
      params: { url: url },
      headers: {
        'accept': 'application/json, text/plain, */*',
        'referer': 'https://threads.snapsave.app/',
        'user-agent': 'Postify/1.0.0',
      },
      timeout: 10000,
    })

    const type = (type) => ({
      GraphImage: 'Photo',
      GraphVideo: 'Video',
      GraphSidecar: 'Gallery',
    }[type] || type)

    return {
      postInfo: {
        id: data.postinfo.id,
        username: data.postinfo.username,
        avatarUrl: data.postinfo.avatar_url,
        mediaTitle: data.postinfo.media_title,
        type: type(data.postinfo.__type),
      },
      media: data.items.map((item) => ({
        type: type(item.__type),
        id: item.id,
        url: item.url,
        width: item.width,
        height: item.height,
        ...(item.__type === 'GraphVideo' && {
          thumbnailUrl: item.display_url,
          videoUrl: item.video_url,
          duration: item.video_duration,
        }),
      })),
    }
  } catch (err) {
    throw Error(err.message)
  }
}

async function terabox(url) {
  const terabox = {
    api: {
      base: "https://teraboxdl.site/api/",
      token: "token",
      terabox: "terabox"
    },
    headers: {
      'authority': 'teraboxdl.site',
      'user-agent': 'Postify/1.0.0'
    },
    token: null
  }

  const getToken = async () => {
    if (terabox.token) return terabox.token

    try {
      const { data } = await axios.get(`${terabox.api.base}${terabox.api.token}`, { headers: terabox.headers })

      terabox.token = data.token
      return terabox.token

    } catch (err) {
      throw Error(err.message)
    }
  }

  const isUrl = (url) => {
    const match = url.match(/https?:\/\/(?:www\.)?(?:\w+)\.(com|app)\/s\/([^\/]+)/i)
    return match ? `https://1024terabox.com/s/${match[2]}` : null
  }

  const request = async (endpoint, params = {}) => {
    const token = await getToken()
    const url = `${terabox.api.base}${endpoint}?` + new URLSearchParams(params)

    try {
      const { data } = await axios.get(url, { headers: { ...terabox.headers, 'x-access-token': token } })
      const fileData = data.data.all_files[0]

      return {
        file_name: fileData.file_name,
        file_id: fileData.fs_id,
        size: fileData.size,
        thumbnail: fileData.thumb,
        download: fileData.download_url,
        bytes: fileData.sizebytes
      }

    } catch (err) {
      throw Error(err.message)
    }
  }

  const linkNya = isUrl(url.trim())
  return await request(terabox.api.terabox, { url: linkNya })
}

async function twitter(url) {
    try {
        const res = await axios.post('https://api.snapfirecdn.com/twitter', { target: url, gsc: 'HFMms5IRIYTm1cFX4MHEEdHQd5XwVkJWN0Sj9pahFfMRdcfhVxVVt2NmElAjAQPkd5QBh5W0RRVhhCZQYxeA0yIFMpK3FXVBpYU1dQbXg5NjxxDkVmCnwFdBIRLQ9KNU8WXitUXDYuLiNHJFVmTVp5O38COXQGFDZFQHISPV8iOzNWVilKVhg7Qwd5LgVkVGJwP0kzDEUtNUApEkltEV0ZNBIEHTE6BllvJGw5MEMtRXwiEXM_B0l0IRAWAzYTIRwHK2UHDXN-bA5vFnBhEn8ydQUuM3k0H285LClVFTNAMycFIWYYI3luL14bFGlVOVBsMhcSU1J3XjolQ0MXEkIfMFcjBlcgKGcNKmQ5Kg0hSn4fPUokAHBjdzs_UhszN0I_ElsTCWkAJFtEMWZGNnZEAWVoFFY_VDc7Fn8wF0kuFQ5SKVVOU2AsSHMZe0kaIXpKMCAvGjMgWngUHE4hLkQ7E3M2TEFfM2U-WHQRSU8AChUtREpJBxMaKngOFVodKwIATVUjAn8-bHdaKmwhAiEGTTg8BAcEKGFPJx4KIUIMPVICcEYcFU5aLlENKjAWNDQoBUgeHmpnF2hATVleU3IMTQhAdnk1JV1KNH8jT0shWVYsEDo6NAlmMVoFKFcHCld6QUs1aHUcJ2ZeNk8WP2JLQGMAFRETUwcmDyJkGVcaMWIbCxYNElU_WxdDLCg5HGtuC3txRHAcPWIHJwM4HhJXPmlkaS81AihEIiEmCFsFKWtEQ1M5SV8DbU8xBkcnNhgeN1sSVG8yb1pEPGhoPFBuO0IiOGQqNXVQMhUZaUBjCDgrBUgJA0QZRVAkNXQfKjh0DDhoFBYeN0QyG04jNlwWVDs9GwUTEwR8CV4gMUBIJ0Ykd15EMghwHlYYOEY6NiwuUGMhCngtHQhmS1U2Bn5QZ3RPJmc1BwdJPn0cC29eMygsHTRiOHxsHWcwNW0gN011fQ5VS0QpLW8HNmMoI3o1JmwlCHcsIz0VMk4iaFUHZx8eD3ATLnQZdGRCXm0WPntqLG15IWUUMFtGBhlAFF03PEkxDEA3BjkYLCFGBXc_CxlIGEduS2k2dHFBDWgLR1kvPUxXOFMiY0dEF2UcKUxFD1JwMzYFF1NOWREVW28gDTgtKmoxQnMAFEQPQGIcXgIUTUkSI1gtVF0rAXYxMnEBVCQ_DzUfE1BLPx8bQX0qPVs8OQczOQ52IAoSCmFFFgMaJlhAbFkJPxprE0F8FDo3aApVekQ8RWYqLUovGEkuVGg8HU4_TnJWFXsAD3EVJng-TWEQSUAfXDENN1IsGRMdRUkiKGQvHjpuF34nBH82NElYDEU2CXoZbAEeX2g0IGtvIUx4LFAAQXA8A2sCHg94f1E_HjAeHQotD1shDF0SAS13LVFEDzwkbmscA0YPIEcTP3Q1KVYcUyJCIUUILgltA00xMmIECTBeZXYFcH4iJTsaO21NQ0cWB2wqWnoSATsCNVYyKXVbY0kff0ACJVwwURsJMjJYJWdiIW8YPFlBORtIJwA_M3VHAURwFFQDSj86MSQaDFh8G2luI2BDN20GbUYbB2lLHHAuSUMwG0E1cmcYZlsISlRuAgoGNUEGL3c2QW4vPHMNEhsFP10_FnUJAkEfLHo-XhcvHXkpEXY6extHD2wECSkGTwo9Pzw9K1NLFF8bEh0ZFmg3FF87Hm43F3NkCC8IVxIkBkJCO1wIDDw0D0F8Nmc1f3hVG0kUG3VMEn8XA0ApWnIXP0g9KQo-AFMNHDYcAkxdVWkOTW0-Uho8Jis8QHUxCk0bC0EeCTstKlw2EhgYUHgMEmweBW8-UgtEDmUdIUV0H2QxHlhBJ2k8El8gNnRlPUACN2EDFTA-EXsnbUcyCBN4H39-SGEQQUooL1wMGhs6TlsrTH4FUmkiYUoKGHU6F10HHE8teTc6UBoMTxNiLBgXAkM9R1JLI1ccCnkbMz8gD2AACncia3dcCmMWU2IwTxgWMTY9YwBoD2Z9KXkMEGVGKmw9OwdUA0IwHWkHKjQREEY2aEZ_FidbAwt6D39ZZWQdNkwKBH45HU4SDDwbJiUvFEQKPUhLW1kNSnwWBUNaP0dZZxYwJioCBH0UHkEqKXMPAlUEVmYlCnxmP3QrcUwnBW0OAm4SfQtGLWwkMAt3Vht_B0IyXmQmKXkCAndKB0UuOkoqD2siF1UCEV0SailSGEtlHD0Wa1gfZxhKVh88' }, {
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Mobile Safari/537.36',
                'Referer': 'https://snaptwitter.io/en'
            }
        })

        const json = res.data

        return {
            username: json.username || 'Unknown',
            medias: json.medias ? json.medias.map(media => ({
                type: media.type || 'Unknown',
                media: media.media || null,
                bitrate: media.bitrate || null,
                contentType: media.content_type || null,
                thumbnail: media.thumbnail || null
            })) : []
        }
    } catch (err) {
        throw Error(err.message)
    }
}

async function gdrive(url) {
  let id = (url.match(/\/?id=(.+)/i) || url.match(/\/d\/(.*?)\//))[1]

  let { data } = await axios.post(`https://drive.google.com/uc?id=${id}&authuser=0&export=download`, null, {
    headers: {
      'accept-encoding': 'gzip, deflate, br',
      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
      'origin': 'https://drive.google.com',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36',
      'x-client-data': 'CKG1yQEIkbbJAQiitskBCMS2yQEIqZ3KAQioo8oBGLeYygE=',
      'x-drive-first-party': 'DriveWebUi',
      'x-json-requested': 'true'
    }
  })

  let { fileName, sizeBytes, downloadUrl } = JSON.parse(data.slice(4))

  return {
    download: downloadUrl,
    fileName,
    fileSize: `${(sizeBytes / (1024 * 1024)).toFixed(2)} MB`,
    mimetype: (await axios.head(downloadUrl)).headers['content-type'],
    extension: fileName.split('.').pop(),
    modified: (await axios.head(downloadUrl)).headers['last-modified']
  }
}

async function mediafire(url) {
  try {
    const { data: text } = await axios.get('https://r.jina.ai/' + url)

    const result = {
      title: (text.match(/Title: (.+)/) || [])[1]?.trim() || '',
      filename: '',
      extension: '',
      size: '',
      download: '',
      repair: '',
      url: (text.match(/URL Source: (.+)/) || [])[1]?.trim() || ''
    }

    const matches = [...text.matchAll(/\[(.*?)\]\((https:\/\/[^\s]+)\)/g)]
    for (const match of matches) {
      const desc = match[1].trim()
      const link = match[2].trim()
      
      if (desc.toLowerCase().includes('download') && desc.match(/\((\d+(\.\d+)?[KMGT]B)\)/)) {
        result.url = link
        result.size = (desc.match(/\((\d+(\.\d+)?[KMG]?B)\)/) || [])[1] || ''
      }
      if (desc.toLowerCase().includes('repair')) {
        result.repair = link
      }
    }

    if (result.url) {
      const decodedUrl = decodeURIComponent(result.url)
      const fileMatch = decodedUrl.match(/\/([^\/]+\.[a-zA-Z0-9]+)(?:\?|$)/)
      if (fileMatch) {
        result.filename = fileMatch[1]
        result.extension = result.filename.split('.').pop().toLowerCase()
      }
    }

    return result
  } catch (err) {
    throw Error(err.message)
  }
}

async function pinterest(url) {
  try {
    const response = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
      }
    })
    const $ = cheerio.load(response.data)

    const title = $('meta[property="og:title"]').attr('content') || '-'
    const description = $('meta[name="description"]').attr('content') || '-'
    const uploaded = $('meta[property="og:updated_time"]').attr('content') || '-'

    const height = $('meta[property="og:image:height"]').attr('content') || '-'
    const width = $('meta[property="og:image:width"]').attr('content') || '-'
    const fullsource = $('meta[property="pinterestapp:pinboard"]').attr('content') || '-'
    const source = fullsource ? new URL(fullsource).hostname : '-' 

    const { data } = await axios.get(url)
    const img = []
    const $$ = cheerio.load(data)
    $$('img').each((i, el) => {
      img.push($$(el).attr('src'))
    })

    return {
      title,
      description,
      uploaded,
      height,
      width,
      source,
      fullsource,
      url,
      img,
    }
  } catch (err) {
    throw Error(err.message)
  }
}

async function soundcloud(url) {
  try {
    const getToken = await axios.get("https://soundcloudmp3.org/", {
      headers: {
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0",
      },
    })
    const dom = getToken.data
    const a = cheerio.load(dom)
    const token = a("input").attr("value")
    const config = {
      _token: token,
      lang: "en",
      url: url,
      submit: "",
    }

    const { data, status } = await axios.post("https://soundcloudmp3.org/converter", new URLSearchParams(config), {
      headers: {
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0",
      },
    })

    if (status === 200) {
      const $ = cheerio.load(data)
      const result = {}
      $(".info > p").each((a, i) => {
        let name = $(i).find("b").text()
        let key = $(i).text().trim().replace(name, "").trim()
        result[name.split(":")[0].trim().toLowerCase()] = key
      })
      result.thumbnail = $(".info img").attr("src")
      result.download = $("#ready-group a").attr("href")
      return result
    }
  } catch (err) {
    throw Error(err.message)
  }
}

async function sfileDl(url) {
  return new Promise(async (resolve, reject) => {
    try {
      const headers = {
        'referer': url,
        'user-Agent': 'Mozilla/5.0 (Linux; Android 14; NX769J Build/UKQ1.230917.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/130.0.6723.107 Mobile Safari/537.36',
      };

      let getPage = await axios.get(url, { headers });
      let $ = cheerio.load(getPage.data);
      let safelink = $("#safe_link").attr("href");

      headers.cookie = getPage.headers['set-cookie'].map(c => c.split(';')[0]).join('; ');
      headers.referer = safelink;

      let resPage = await axios.get(safelink, { headers });
      let s,f = cheerio.load(resPage.data);

      const [dl, [name, ext, size], downloaded, uploaded, mime, author] = [
        f("#download").attr("href")+'&k='+f("#download").attr("onclick").match(/&k='\+(.*?)';/)?.[1].replace("'",''),
        (()=>{s=f('.w3-text-blue b').text().match(/^(.+?)(?:\.([^.\s()]+))?(?:\s*\(([^)]*)\))?$/);return[s[1].trim(),s[2],s[3]]})(),
        $('.icon-cloud-download').parent().text().split(':')[1].trim(),
        $('.icon-upload').parent().text().split(':')[1].trim(),
        $('.list:nth-child(2)').eq(0).text().slice(3).trim(),
        $('.list a').first().text().trim(),
      ]

      resolve({
        name,
        size,
        author,
        uploaded,
        downloaded,
        mime,
        ext,
        dl
      });
    } catch (e) {
      reject(e);
    }
  })
}

// === Search

const agent = new https.Agent({
    rejectUnauthorized: true,
    maxVersion: 'TLSv1.3',
    minVersion: 'TLSv1.2'
})

async function getCookies() {
    try {
        const response = await axios.get('https://www.pinterest.com/csrf_error/', { httpsAgent: agent })
        const setCookieHeaders = response.headers['set-cookie']
        if (setCookieHeaders) {
            const cookies = setCookieHeaders.map(cookieString => {
                const cookieParts = cookieString.split(';')
                return cookieParts[0].trim()
            })
            return cookies.join('; ')
        }
        return null
    } catch {
        return null
    }
}

async function pinterestSearch(query) {
    try {
        const cookies = await getCookies()
        if (!cookies) return []
        const params = {
            source_url: `/search/pins/?q=${query}`,
            data: JSON.stringify({
                options: {
                    isPrefetch: false,
                    query: query,
                    scope: "pins",
                    no_fetch_context_on_resource: false
                },
                context: {}
            }),
            _: Date.now()
        }

        const headers = {
            'accept': 'application/json, text/javascript, */*, q=0.01',
            'accept-encoding': 'gzip, deflate',
            'accept-language': 'en-US,en;q=0.9',
            'cookie': cookies,
            'dnt': '1',
            'referer': 'https://www.pinterest.com/',
            'sec-ch-ua': '"Not(A:Brand";v="99", "Microsoft Edge";v="133", "Chromium";v="133"',
            'sec-ch-ua-full-version-list': '"Not(A:Brand";v="99.0.0.0", "Microsoft Edge";v="133.0.3065.92", "Chromium";v="133.0.6943.142"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-model': '""',
            'sec-ch-ua-platform': '"Windows"',
            'sec-ch-ua-platform-version': '"10.0.0"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-origin',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36 Edg/133.0.0.0',
            'x-app-version': 'c056fb7',
            'x-pinterest-appstate': 'active',
            'x-pinterest-pws-handler': 'www/[username]/[slug].js',
            'x-pinterest-source-url': '/hargr003/cat-pictures/',
            'x-requested-with': 'XMLHttpRequest'
        }

        const { data } = await axios.get('https://www.pinterest.com/resource/BaseSearchResource/get/', { httpsAgent: agent, headers, params })
        return data.resource_response.data.results
            .filter(v => v.images?.orig)
            .map(result => ({
                uploaded: result.pinner.username,
                fullname: result.pinner.full_name,
                followers: result.pinner.follower_count,
                caption: result.grid_title,
                images: result.images.orig.url,
                source: 'https://id.pinterest.com/pin/'+result.id,
            }))
    } catch(err) {
        throw Error(err.message)
    }
}

async function stickerSearch(query) {
  const link = await axios.get(`https://getstickerpack.com/stickers?query=${query}`);
  const $ = cheerio.load(link.data)
  let sticker1 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(1) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(1) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(1) > a > div > span.username').text().trim()
  }
  let sticker2 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(2) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(2) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(2) > a > div > span.username').text().trim()
  }
  let sticker3 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(3) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(3) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(3) > a > div > span.username').text().trim()
  }
  let sticker4 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(4) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(4) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(4) > a > div > span.username').text().trim()
  }
  let sticker5 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(5) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(5) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(5) > a > div > span.username').text().trim()
  }
  let sticker6 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(6) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(6) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(6) > a > div > span.username').text().trim()
  }
  let sticker7 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(7) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(7) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(7) > a > div > span.username').text().trim()
  }
  let sticker8 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(8) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(8) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(8) > a > div > span.username').text().trim()
  }
  let sticker9 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(9) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(9) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(9) > a > div > span.username').text().trim()
  }
  let sticker10 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(10) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(10) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(10) > a > div > span.username').text().trim()
  }
  let sticker11 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(11) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(11) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(11) > a > div > span.username').text().trim()
  }
  let sticker12 = {
    sticker: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(12) > a > div > img').attr('src'),
    nama: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(12) > a > div > span.title').text().trim(),
    creator: $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(12) > a > div > span.username').text().trim()
  }
  let stickerlop = [
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(1) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(2) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(3) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(4) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(5) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(6) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(7) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(8) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(9) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(10) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(11) > a > div > img').attr('src'),
    $('#stickerPacks').find('div > div:nth-child(3) > div:nth-child(12) > a > div > img').attr('src')
  ]
  let data = {
    sticker: stickerlop,
    sticker1,
    sticker2,
    sticker3,
    sticker4,
    sticker5,
    sticker6,
    sticker7,
    sticker8,
    sticker9,
    sticker10,
    sticker11,
    sticker12
  }
  return data
}

async function googleSearch(query) {
  try {
    const response = await fetch(`https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(query)}&key=AIzaSyAajE2Y-Kgl8bjPyFvHQ-PgRUSMWgBEsSk&cx=e5c2be9c3f94c4bbb`)
    const data = await response.json()

    if (!data.items || data.items.length === 0) {
      return []
    }

    return data.items.map(item => ({
      title: item.title,
      description: item.snippet,
      link: item.link
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

async function gimageSearch(query) {
  const url = `https://www.google.com/search?q=${query}&tbm=isch`
  const headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, seperti Gecko) Chrome/96.0.4664.93 Safari/537.36',
    'Accept-Language': 'en-US,en;q=0.9,id;q=0.8',
  }

  const response = await axios.get(url, { headers })
  const data = response.data

  const $ = cheerio.load(data)
  const pattern =
    /\[1,\[0,"(?<id>[\d\w\-_]+)",\["https?:\/\/(?:[^"]+)",\d+,\d+\]\s?,\["(?<url>https?:\/\/(?:[^"]+))",\d+,\d+\]/gm
  const matches = $.html().matchAll(pattern)
  const decodeUrl = (url) => decodeURIComponent(JSON.parse(`"${url}"`))
  return [...matches]
    .map(({ groups }) => decodeUrl(groups?.url))
    .filter((v) => /.*\.jpe?g|png$/gi.test(v))
}

async function playstoreSearch(query) {
  try {
    const { data } = await axios.get(`https://play.google.com/store/search?q=${query}&c=apps`)
    const hasil = []
    const $ = cheerio.load(data)

    $('.ULeU3b > .VfPpkd-WsjYwc.VfPpkd-WsjYwc-OWXEXe-INsAgc.KC1dQ.Usd1Ac.AaN0Dd.Y8RQXd > .VfPpkd-aGsRMb > .VfPpkd-EScbFb-JIbuQc.TAQqTe > a').each((i, u) => {
      const linkk = $(u).attr('href')
      const nama = $(u).find('.j2FCNc > .cXFu1 > .ubGTjb > .DdYX5').text()
      const developer = $(u).find('.j2FCNc > .cXFu1 > .ubGTjb > .wMUdtb').text()
      const img = $(u).find('.j2FCNc > img').attr('src')
      const rate = $(u).find('.j2FCNc > .cXFu1 > .ubGTjb > div').attr('aria-label')
      const rate2 = $(u).find('.j2FCNc > .cXFu1 > .ubGTjb > div > span.w2kbF').text()
      const link = `https://play.google.com${linkk}`

      hasil.push({
        link: link,
        nama: nama ? nama : 'No name',
        developer: developer ? developer : 'No Developer',
        img: img ? img : 'https://i.ibb.co/G7CrCwN/404.png',
        rate: rate ? rate : 'No Rate',
        rate2: rate2 ? rate2 : 'No Rate',
        link_dev: `https://play.google.com/store/apps/developer?id=${developer.split(" ").join('+')}`
      })
    })

    if (hasil.every(x => x === undefined)) return { message: 'Gak ada hasilnya' }
    return hasil
  } catch (err) {
    throw Error(err.message)
  }
}

async function appstoreSearch(query) {
  try {
    const res = await fetch(`https://www.apple.com/us/search/${encodeURIComponent(query)}?src=globalnav`)
    const html = await res.text()
    const obj = html.split('window.pageLevelData.searchResults.searchData = ')[1].split('};\n')[0]
    const data = JSON.parse(obj + '}')

    const searchResults = data.results.explore.exploreCurated.tiles.items.map(item => ({
      title: item.value.title,
      description: item.value.description || 'Tidak ada deskripsi',
      url: item.value.navLinks[0]?.url || null,
      image: item.imageURL || null,
      rank: item.value.resultRank || 'Tidak ada rank'
    }))

    return {
      total_results: data.totalCountText || 'Tidak ada hasil',
      search_term: data.searchTerm || query,
      first_result_link: searchResults[0]?.url || null,
      results: searchResults
    }
  } catch (err) {
    throw Error(err.message)
  }
}

async function wikipediaSearch(teks) {
  try {
    const response = await fetch(
      `https://en.wikipedia.org/w/api.php?action=query&list=search&format=json&origin=*&srsearch=${teks}`
    )
    const data = await response.json()
    return data.query.search.map((item) => ({
      judul: item.title,
      desk: item.snippet.replace(/<\/?[^>]+(>|$)/g, ''),
      link: `https://en.wikipedia.org/wiki/${encodeURIComponent(item.title)}`,
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

async function wikimediaSearch(query) {
  try {
    let res = await axios.get(`https://commons.wikimedia.org/w/index.php?search=${encodeURIComponent(query)}&title=Special:MediaSearch&go=Go&type=image`)
    let $ = cheerio.load(res.data)
    let hasil = []
    $('.sdms-search-results__list-wrapper > div > a').each(function (a, b) {
      hasil.push({
        title: $(b).find('img').attr('alt'),
        source: $(b).attr('href'),
        image: $(b).find('img').attr('data-src') || $(b).find('img').attr('src')
      })
    })
    return hasil
  } catch (err) {
    throw Error(err.message)
  }
}

async function wikiImageSearch(teks) {
  try {
    const response = await axios.get('https://en.wikipedia.org/w/api.php', {
      params: {
        action: 'query',
        format: 'json',
        generator: 'search',
        gsrsearch: teks,
        prop: 'pageimages',
        piprop: 'original',
        pilimit: 'max',
      },
    })

    const halaman = response.data.query.pages
    return Object.values(halaman).map((page) => ({
      title: page.title,
      image: page.original ? page.original.source : null,
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

async function soundcloudSearch(search) {
  try {
    const { data } = await axios.get(`https://soundcloud.com/search?q=${search}`)
    const $ = cheerio.load(data)
    const ajg = []
    $("#app > noscript").each((u, i) => {
      ajg.push($(i).html())
    })
    const _$ = cheerio.load(ajg[1])
    const hasil = []
    _$("ul > li > h2 > a").each((i, u) => {
      if ($(u).attr("href").split("/").length === 3) {
        const linkk = $(u).attr("href")
        const judul = $(u).text()
        hasil.push({
          url: `https://soundcloud.com${linkk || "-"}`,
          title: judul || '-',
        })
      }
    })
    return hasil
  } catch (err) {
    throw Error(err.message)
  }
}

async function youtubeSearch(query) {
  try {
    const searchResults = await ytSearch.search(query)
    const videos = searchResults.videos.map(video => ({
      title: video.title,
      description: video.description,
      url: video.url,
      videoId: video.videoId,
      timestamp: video.timestamp,
      duration: video.duration,
      ago: video.ago,
      views: video.views,
      author: {
        name: video.author.name,
        url: video.author.url,
        verified: video.author.verified
      },
      image: video.image,
      thumbnail: video.thumbnail
    }))
    return videos
  } catch (err) {
    throw Error(err.message)
  }
}

async function getAccessToken() {
  try {
    const client_id = 'acc6302297e040aeb6e4ac1fbdfd62c3'
    const client_secret = '0e8439a1280a43aba9a5bc0a16f3f009'
    const basic = Buffer.from(`${client_id}:${client_secret}`).toString('base64')
    const response = await axios.post('https://accounts.spotify.com/api/token', 'grant_type=client_credentials', {
      headers: {
        Authorization: `Basic ${basic}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    })
    return response.data.access_token
  } catch (err) {
    throw Error(err.message)
  }
}

async function spotifySearch(query) {
  try {
    const { data } = await axios.get(`https://www.bhandarimilan.info.np/spotisearch?query=${query}`);
    const results = data.map(ft => ({
      nama: ft.name,
      artis: ft.artist,
      rilis: ft.release_date,
      durasi: ft.duration,
      link: ft.link,
      image: ft.image_url
    }))
    return results
  } catch(err) {
    throw Error(err.message)
  }
}

async function tiktokSearch(query) {
  return new Promise(async (resolve, reject) => {
    axios("https://tikwm.com/api/feed/search", {
      headers: {
        "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        cookie: "current_language=en",
        "User-Agent": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36",
      },
      data: {
        keywords: query,
        count: 12,
        cursor: 0,
        web: 1,
        hd: 1,
      },
      method: "POST",
    })
      .then((res) => {
        if (!res.data || !res.data.data || !res.data.data.videos) {
          return reject(Error("Data tidak ditemukan"))
        }

        const result = res.data.data.videos.map((video) => ({
          id: video.video_id,
          title: video.title,
          cover: `https://tikwm.com${video.cover}`,
          duration: video.duration,
          play_url: `https://tikwm.com${video.play}`,
          wmplay_url: `https://tikwm.com${video.wmplay}`,
          size: video.size,
          wm_size: video.wm_size,
          music_url: `https://tikwm.com${video.music}`,
          play_count: video.play_count,
          digg_count: video.digg_count,
          comment_count: video.comment_count,
          share_count: video.share_count,
          download_count: video.download_count,
          create_time: video.create_time,
          author_id: video.mentioned_users,
          region: video.region
        }))

        resolve(result)
      })
      .catch((err) => reject(Error(err.message)))
  })
}

async function librarySearch(teks) {
  try {
    const response = await axios.get('https://openlibrary.org/search.json', {
      params: { q: teks },
    })
    return response.data.docs.map((book) => ({
      title: book.title,
      author: book.author_name ? book.author_name.join(', ') : 'Unknown',
      cover: book.cover_i ? `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg` : null,
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

async function unsplashSearch(query) {
  try {
    const response = await axios.get(`https://unsplash.com/napi/search/photos`, {
      params: { query, per_page: 10 },
    })
    return response.data.results.map((rorr) => ({
      judul: rorr.alt_description,
      gambar: rorr.urls.regular,
      link: rorr.links.html,
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

async function sfileSearch(query) {
  try {
    const response = await fetch(`https://sfile.mobi/search.php?q=${encodeURIComponent(query)}&search=Search`)
    const html = await response.text()
    const $ = cheerio.load(html)

    const result = $('div.w3-card.white > div.list').map((_, el) => {
      const anchor = $(el).find('a')
      const name = anchor.text()
      const link = anchor.attr('href')
      const sizeText = $(el).text().split('(')[1]
      const size = sizeText ? sizeText.split(')')[0] : 'Unknown'

      return { name, size, link }
    }).get()

    return result
  } catch (err) {
    throw Error(err.message)
  }
}

async function npmSearch(query) {
  try {
    let res = await fetch(`http://registry.npmjs.com/-/v1/search?text=${encodeURIComponent(query)}`)
    let { objects } = await res.json()

    return objects.map(({ package: pkg }) => ({
      package: pkg.name,
      version: pkg.version,
      url: pkg.links.npm,
      description: pkg.description || '-'
    }))
  } catch (err) {
    throw Error(err.message)
  }
}

// === Tools

async function screenshotWeb(url) {
    try {
        if (!/^https?:\/\//.test(url)) url = 'https://' + url

        const response = await axios.get(`https://image.thum.io/get/png/fullpage/viewportWidth/2400/${url}`, {
            responseType: 'arraybuffer'
        })

        const filePath = `./screenshot_${randomKarakter(4)}.png`
        fs.writeFileSync(filePath, response.data)

        const image_url = await tempfiles(filePath)
        fs.unlinkSync(filePath)

        return {
            status: 200,
            image_url
        }
    } catch (err) {
        throw Error(err.message)
    }
}

async function screenshotToCode(input) {
    try {
        let imageBuffer

        if (Buffer.isBuffer(input)) {
            imageBuffer = input
        } else if (fs.existsSync(input)) {
            imageBuffer = fs.readFileSync(input)
        } else if (typeof input === 'string' && input.startsWith('http')) {
            const response = await axios.get(input, { responseType: 'arraybuffer' })
            imageBuffer = Buffer.from(response.data)
        } else {
            throw Error('Input tidak valid')
        }

        return await new Promise((resolve, reject) => {
            const ws = new WebSocket('wss://screenshot-to-code-xe2d.onrender.com/generate-code')
            let finalCode = ''

            ws.on('open', () => {
                const base64Image = imageBuffer.toString('base64')

                const data = {
                    generationType: "create",
                    image: `data:image/jpeg;base64,${base64Image}`,
                    inputMode: "image",
                    openAiApiKey: null,
                    openAiBaseURL: null,
                    anthropicApiKey: null,
                    screenshotOneApiKey: null,
                    isImageGenerationEnabled: true,
                    editorTheme: "cobalt",
                    generatedCodeConfig: "html_tailwind",
                    codeGenerationModel: "gpt-4o-2024-05-13",
                    isTermOfServiceAccepted: false
                }

                ws.send(JSON.stringify(data))
            })

            ws.on('message', (message) => {
                const response = JSON.parse(message.toString())

                if (response.type === 'setCode') {
                    finalCode = response.value
                }
            })

            ws.on('close', () => {
                resolve(finalCode.trim())
            })

            ws.on('error', (error) => {
                reject(Error(error.message))
            })
        })
    } catch (err) {
        throw Error(err.message)
    }
}

const acr = new acrcloud({
  host: "identify-eu-west-1.acrcloud.com",
  access_key: "c9f2fca5e16a7986b0a6c8ff70ed0a06",
  access_secret: "PQR9E04ZD60wQPgTSRRqwkBFIWEZldj0G3q7NJuR"
})

async function whatmusic(input) {
  try {
    let file_path = './sampah.mp3'

    if (Buffer.isBuffer(input)) {
      fs.writeFileSync(file_path, input)
    } else if (typeof input === 'string') {
      if (/^https?:\/\//.test(input)) {
        let response = await axios.get(input, { responseType: 'arraybuffer' })
        fs.writeFileSync(file_path, Buffer.from(response.data))
      } else if (fs.existsSync(input)) {
        file_path = input
      }
    } else {
      throw Error('Harus berupa URL, file atau buffer!')
    }

    let outputna = './hasilnya.mp3'

    return new Promise((resolve, reject) => {
      ffmpeg(file_path)
        .audioCodec('libmp3lame')
        .saveToFile(outputna)
        .on('error', (err) => {
          fs.unlinkSync(file_path)
          reject(err.message)
        })
        .on('end', async () => {
          fs.unlinkSync(file_path)
          let sample = fs.readFileSync(outputna)

          acr.identify(sample).then((metadata) => {
            fs.unlinkSync(outputna)
            if (metadata.status.msg === 'No result') {
              return reject('Nggak ketemu :(')
            }

            let song = metadata.metadata.music[0]
            let spotify_data = song.external_metadata?.spotify
            let youtube_id = song.external_metadata?.youtube?.vid || null

            resolve({
              title: song.title,
              artists: song.artists.map(a => a.name).join(', '),
              album: song.album.name,
              release_date: song.release_date,
              label: song.label,
              duration: song.duration_ms,
              spotify: spotify_data?.track?.id ? { name: song.title, url: `https://open.spotify.com/track/${spotify_data.track.id}` } : null,
              youtube: youtube_id ? `https://www.youtube.com/watch?v=${youtube_id}` : null
            })
          }).catch((err) => reject(err.message))
        })
    })
  } catch (err) {
    throw Error(err.message)
  }
}

async function enhance(filePath) {
  const buffer = fs.readFileSync(filePath)
  const ext = path.extname(filePath).slice(1) || 'bin'
  const mime = ext === 'png' ? 'image/png' : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'application/octet-stream'
  const fileName = Math.random().toString(36).slice(2, 8) + '.' + ext

  const { data } = await axios.post("https://pxpic.com/getSignedUrl", {
    folder: "uploads",
    fileName
  }, { headers: { "Content-Type": "application/json" } })

  await axios.put(data.presignedUrl, buffer, { headers: { "Content-Type": mime } })
  const url = "https://files.fotoenhancer.com/uploads/" + fileName

  const api = await axios.post("https://pxpic.com/callAiFunction", new URLSearchParams({
    imageUrl: url,
    targetFormat: 'png',
    needCompress: 'no',
    imageQuality: '100',
    compressLevel: '6',
    fileOriginalExtension: 'png',
    aiFunction: 'enhance',
    upscalingLevel: ''
  }).toString(), {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8',
      'Content-Type': 'application/x-www-form-urlencoded',
      'accept-language': 'id-ID'
    }
  })

  return api.data.resultImageUrl
}

async function upscale(filePath) {
  const buffer = fs.readFileSync(filePath)
  const ext = path.extname(filePath).slice(1) || 'bin'
  const mime = ext === 'png' ? 'image/png' : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'application/octet-stream'
  const fileName = Math.random().toString(36).slice(2, 8) + '.' + ext

  const { data } = await axios.post("https://pxpic.com/getSignedUrl", {
    folder: "uploads",
    fileName
  }, { headers: { "Content-Type": "application/json" } })

  await axios.put(data.presignedUrl, buffer, { headers: { "Content-Type": mime } })
  const url = "https://files.fotoenhancer.com/uploads/" + fileName

  const api = await axios.post("https://pxpic.com/callAiFunction", new URLSearchParams({
    imageUrl: url,
    targetFormat: 'png',
    needCompress: 'no',
    imageQuality: '100',
    compressLevel: '6',
    fileOriginalExtension: 'png',
    aiFunction: 'upscale',
    upscalingLevel: ''
  }).toString(), {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8',
      'Content-Type': 'application/x-www-form-urlencoded',
      'accept-language': 'id-ID'
    }
  })

  return api.data.resultImageUrl
}

async function recolor(filePath) {
  return new Promise(async (resolve, reject) => {
    const outputPath = `./recolor_${randomKarakter(4)}.jpg`
    const cmd = `ffmpeg -y -loglevel error -i ${filePath} -vf "curves=r='0/0 0.5/0.6 1/1':g='0/0 0.5/0.55 1/1':b='0/0 0.5/0.65 1/1'" ${outputPath}`
    
    exec(cmd, async (err) => {
      if (err) return reject(new Error(`Terjadi kesalahan: ${err.message}`))
      let uploadUrl = await tempfiles(outputPath)
      fs.unlinkSync(outputPath)
      resolve(uploadUrl)
    })
  })
}

async function dehaze(filePath) {
  return new Promise(async (resolve, reject) => {
    const outputPath = `./dehaze_${randomKarakter(4)}.jpg`
    const cmd = `ffmpeg -i ${filePath} -vf "colorchannelmixer=rr=0.75:gg=0.65:bb=0.5, eq=contrast=0.75:saturation=0.4:brightness=-0.15, gblur=sigma=1.2" ${outputPath}`
    
    exec(cmd, async (err) => {
      if (err) return reject(new Error(`Terjadi kesalahan: ${err.message}`))
      let uploadUrl = await tempfiles(outputPath)
      fs.unlinkSync(outputPath)
      resolve(uploadUrl)
    })
  })
}

async function removeBg(filePath) {
  const buffer = fs.readFileSync(filePath)
  const ext = path.extname(filePath).slice(1) || 'bin'
  const mime = ext === 'png' ? 'image/png' : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'application/octet-stream'
  const fileName = Math.random().toString(36).slice(2, 8) + '.' + ext

  const { data } = await axios.post("https://pxpic.com/getSignedUrl", {
    folder: "uploads",
    fileName
  }, { headers: { "Content-Type": "application/json" } })

  await axios.put(data.presignedUrl, buffer, { headers: { "Content-Type": mime } })
  const url = "https://files.fotoenhancer.com/uploads/" + fileName

  const api = await axios.post("https://pxpic.com/callAiFunction", new URLSearchParams({
    imageUrl: url,
    targetFormat: 'png',
    needCompress: 'no',
    imageQuality: '100',
    compressLevel: '6',
    fileOriginalExtension: 'png',
    aiFunction: 'removebg',
    upscalingLevel: ''
  }).toString(), {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8',
      'Content-Type': 'application/x-www-form-urlencoded',
      'accept-language': 'id-ID'
    }
  })

  return api.data.resultImageUrl
}

async function googleTranslate(text, from = "auto", to = "id") {
  const { data } = await axios.get("https://translate.google.com");
  const f_sid = data.match(/"FdrFJe":\s*"([^"]+)"/)?.[1];
  const bl = data.match(/"cfb2h":\s*"([^"]+)"/)?.[1];

  const payload = JSON.stringify([
    [
      [
        "MkEWBc",
        JSON.stringify([[text, from, to, true], [null]]),
        null,
        "generic",
      ],
    ],
  ]);

  const { data: response } = await axios.post(
    "https://translate.google.com/_/TranslateWebserverUi/data/batchexecute",
    "f.req=" + encodeURIComponent(payload) + "&",
    {
      params: {
        rpcids: "MkEWBc",
        "source-path": "/",
        "f.sid": f_sid,
        bl: bl,
        hl: "en-US",
        "soc-app": 1,
        "soc-platform": 1,
        "soc-device": 1,
        _reqid: Math.floor(1000 + Math.random() * 9000),
        rt: "c",
      },
      headers: {
        "content-type": "application/x-www-form-urlencoded;charset=UTF-8",
        referer: "https://translate.google.com/",
        "user-agent":
          "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36",
      },
    },
  );

  let json = response.split("\n")?.[3];
  const result = { text: "", from: "", raw: "" };

  try {
    json = JSON.parse(json);
    json = JSON.parse(json[0][2]);
    result.raw = json;
    if (json[1][0][0][5]) {
      result.text = json[1][0][0][5][0][0];
    }
    if (json[0][2]) {
      result.from = json[0][2];
    }
    if (result.text && result.from) {
      result.voice_from = async () => voice(text, result.from);
      result.voice_to = async () => voice(result.text, to);
    }
  } catch (err) {
    throw Error(err.message)
  }

  return { result: result.text, from: result.from }
}

async function googleTts(text, lang = "id") {
  const { data } = await axios.get("https://translate.google.com");
  const f_sid = data.match(/"FdrFJe":\s*"([^"]+)"/)?.[1];
  const bl = data.match(/"cfb2h":\s*"([^"]+)"/)?.[1];

  const payload = JSON.stringify([
    [
      [
        "jQ1olc",
        JSON.stringify([text, lang, null, "undefined", [0]]),
        null,
        "generic",
      ],
    ],
  ]);

  const { data: response } = await axios.post(
    "https://translate.google.com/_/TranslateWebserverUi/data/batchexecute",
    "f.req=" + encodeURIComponent(payload) + "&",
    {
      params: {
        rpcids: "jQ1olc",
        "source-path": "/",
        "f.sid": f_sid,
        bl: bl,
        hl: "en-US",
        "soc-app": 1,
        "soc-platform": 1,
        "soc-device": 1,
        _reqid: Math.floor(1000 + Math.random() * 9000),
        rt: "c",
      },
      headers: {
        "content-type": "application/x-www-form-urlencoded;charset=UTF-8",
        referer: "https://translate.google.com/",
        "user-agent":
          "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36",
      },
    },
  )

  let json = response.split("\n")?.[3]

  try {
    json = JSON.parse(json)
    json = JSON.parse(json[0][2])
    return { buffer: Buffer.from(json[0], 'base64'), type: 'audio/mpeg' }
  } catch (err) {
    throw Error(err.message)
  }
}

async function shortUrlv1(url) {
  const response = await axios.get('https://v.gd/create.php', {
    params: {
      format: 'simple',
      url: url
    }
  })
  return response.data
}

async function shortUrlv2(url) {
  const response = await axios.get('https://is.gd/create.php', {
    params: {
      format: 'simple',
      url: url
    }
  })
  return response.data
}

// === Maker

async function bratImage(teks) {
    if (!teks) throw Error('Teks tidak boleh kosong')
    if (teks.length > 250) throw Error('Karakter terbatas, max 250!')

    try {
        const res = await axios.get(
            `https://aqul-brat.hf.space/?text=${encodeURIComponent(teks)}`,
            { responseType: "arraybuffer" }
        )

        return { buffer: res.data, type: 'image/png' }
    } catch (err) {
        throw Error(err.message)
    }
}

async function bratVideo(teks) {
    if (!teks) throw Error('Teks tidak boleh kosong')
    if (teks.length > 250) throw Error('Karakter terbatas, max 250!')

    const words = teks.split(" ")
    const framePaths = []

    try {
        for (let i = 0; i < words.length; i++) {
            const currentText = words.slice(0, i + 1).join(" ")

            const res = await axios.get(
                `https://aqul-brat.hf.space/?text=${encodeURIComponent(currentText)}`,
                { responseType: "arraybuffer" }
            ).catch((e) => e.response)

            const framePath = `./frame${i}.mp4`
            fs.writeFileSync(framePath, res.data)
            framePaths.push(framePath)
        }

        const fileListPath = "./filelist.txt"
        let fileListContent = ""

        for (let i = 0; i < framePaths.length; i++) {
            fileListContent += `file '${framePaths[i]}'\n`
            fileListContent += `duration 0.5\n`
        }

        fileListContent += `file '${framePaths[framePaths.length - 1]}'\n`
        fileListContent += `duration 1.5\n`

        fs.writeFileSync(fileListPath, fileListContent)
        const outputVideoPath = "./output.mp4"

        execSync(
            `ffmpeg -y -f concat -safe 0 -i ${fileListPath} -vf "fps=30" -c:v libx264 -preset superfast -pix_fmt yuv420p ${outputVideoPath}`
        )

        const buffer = fs.readFileSync(outputVideoPath)

        framePaths.forEach((frame) => {
            if (fs.existsSync(frame)) fs.unlinkSync(frame)
        })
        if (fs.existsSync(fileListPath)) fs.unlinkSync(fileListPath)
        if (fs.existsSync(outputVideoPath)) fs.unlinkSync(outputVideoPath)

        return { buffer, type: 'video/mp4' }
    } catch (err) {
        throw Error(err.message)
    }
}

async function emojimix(emoji1, emoji2) {
  try {
    let hex1 = emoji1.codePointAt(0).toString(16)
    let hex2 = emoji2.codePointAt(0).toString(16)

    let url = `https://emojik.vercel.app/s/${hex1}_${hex2}?size=512`
    let { data } = await axios.get(url, { responseType: 'arraybuffer' })

    return { buffer: data, type: 'image/png' }
  } catch (err) {
    throw Error(err.message)
  }
}

async function quotly(message, username, avatar = "https://files.catbox.moe/nwvkbt.png") {
  try {
    const json = {
      type: "quote",
      format: "png",
      backgroundColor: "#ffffff",
      width: 512,
      height: 768,
      scale: 2,
      messages: [
        {
          entities: [],
          avatar: true,
          from: {
            id: 1,
            name: username,
            photo: { url: avatar },
          },
          text: message,
          replyMessage: {},
        },
      ],
    }

    const response = await axios.post('https://bot.lyo.su/quote/generate', json, {
      headers: { "Content-Type": "application/json" },
    })

    return response.data.result
  } catch (err) {
    throw Error(err.message)
  }
}

async function carbonV1(input) {
  let Blobs = await fetch("https://carbonara.solopov.dev/api/cook", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "code": input
      })
    })
    .then(response => response.blob())
  let arrayBuffer = await Blobs.arrayBuffer();
  let buffer = Buffer.from(arrayBuffer);
  return { buffer, type: 'image/png' }
}

async function carbonV2(input) {
  let Blobs = await fetch("https://carbon-api.vercel.app/api", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "code": input
      })
    })
    .then(response => response.blob())
  let arrayBuffer = await Blobs.arrayBuffer();
  let buffer = Buffer.from(arrayBuffer);
  return { buffer, type: 'image/png' }
}

module.exports = {
  uploader: {
    catbox,
    uguu,
    theoks,
    litterbox,
    cloudmini,
    tempfiles,
    postimg
  },
  downloader: {
    ytdlv1,
    ytdlv2,
    fbdl,
    igdl,
    ttdl,
    ttslide,
    spotify,
    capcut,
    threads,
    terabox,
    twitter,
    gdrive,
    mediafire,
    pinterest,
    soundcloud,
    sfileDl
  },
  search: {
    pinterestSearch,
    stickerSearch,
    googleSearch,
    gimageSearch,
    playstoreSearch,
    appstoreSearch,
    wikipediaSearch,
    wikimediaSearch,
    wikiImageSearch,
    soundcloudSearch,
    youtubeSearch,
    spotifySearch,
    tiktokSearch,
    librarySearch,
    unsplashSearch,
    sfileSearch,
    npmSearch
  },
  tools: {
    screenshotWeb,
    screenshotToCode,
    whatmusic,
    enhance,
    upscale,
    recolor,
    dehaze,
    removeBg,
    googleTranslate,
    googleTts,
    shortUrlv1,
    shortUrlv2
  },
  maker: {
    bratImage,
    bratVideo,
    emojimix,
    quotly,
    carbonV1,
    carbonV2
  }
}